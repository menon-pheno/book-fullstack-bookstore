# 第四章

- 概述
- `Book` 資料模型
  - `BookSchema`
  - 靜態函式
    - `Book.list()`
    - `Book.getBySlug()`

---

在我們開工之前，先取得`3-end`的程式碼。[3-end](https://github.com/menon-pheno/fullstack-bookstore/tree/master/book/3-end)資料夾位於[fullstack-bookstore repo](https://github.com/menon-pheno/fullstack-bookstore)`book`的目錄內。

- 如果你還沒有將 fullstack-bookstore 給 clone 下來的話，用`git clone https://github.com/menon-pheno/fullstack-bookstore`這個指令將 repo 複製到你的電腦上
- 注意：如果你想要用自己的 GitHub 帳號自己管理程式的話，你應該將我們的 repo fork 出來並且執行`git clone https://github.com/<你的 github 名稱>/fullstack-bookstore.git`。這樣你就可以將你的改動直接 push 到你的`fullstack-bookstore` repo
- 在`3-end`的資料夾內執行`yarn`來安裝所有的套件

我們在第四章會新增以下的套件：

TODO: if there is something

看一下第四章的 [package.json](https://github.com/menon-pheno/fullstack-bookstore/blob/master/book/4-end/package.json)。

請確定使用我們指定的套件跟版本，並忽略任何升級的警告。我們會定期更新套件且測試相容性。我們無法確保新的套件版本與目前的程式碼都相容，套件升級時有的時候會導致一些預料之外的問題。

記得將你第三章更新的 `.env.local` 檔案放到專案的根目錄下。

我們鼓勵且歡迎你在閱讀本章的時候，可以在我們的 GitHub repo: [https://github.com/menon-pheno/fullstack-bookstore/issues/new](https://github.com/menon-pheno/fullstack-bookstore)回報任何 bug、錯字或是任何解釋不清楚的地方。

---

## 概述

我們在前三章裡，建立了一個具有使用 Googlel OAuth 登入的網站架構。嚴格來說，我們這章才會真正進入設計書店。

---

## `Book` 資料模型

前面的章節有提到，`mongoose` 的方便處在於能夠定義資料模型，讓我們交由 `mongoose` 來透過資料模型與 MongoDB 進行資料的處理。我們在這節就來定義一個 `Book` 資料模型，顧名思義，這個資料模型代表了我們書店內的一本“書”，我們新增 `models/Book.js` 這個檔案並且先把程式碼的框架填上：

```JavaScript
import mongoose from "mongoose";

const { Schema } = mongoose;

// BookSchema 定義一個 Book 該有哪些資料
const BookSchema = new Schema({});

// BookClass 定義有哪些操作 Book 的靜態函式
class BookClass {}

// 這樣 BookSchema 就除了資料型態之外，更有我們在 BookClass 內定義的函式
BookSchema.loadClass(BookClass);

export default mongoose.models.Book || mongoose.model("Book", BookSchema);

```

上面的框架我們在第二章示範 `User` 資料模型的時候就做過很類似的過程。唯一的新的概念是 `BookSchema.loadClass(BookClass)`，[mongoose 的官方文件](https://mongoosejs.com/docs/api.html#schema_Schema-loadClass) 有說明，其主要作用是在我們的 `BookSchema` 上面添加函式。本章晚點會有實作，到時應該比較能夠體會它的作用。

因此我們建立 `Book` 資料模型需要做的就是：

- 定義好我們的 `BookSchema`
- 定義好我們需要把哪些（靜態）函式加到 `BookClass`（會透過 `.loadClass()` 被放進資料模型內）

---

### `BookSchema`

我們的 `Book` 資料模型，應該至少會需要以下四個欄位：

- `name`：拿來創建 `slug` 以及讓 SEO 未來可以容易搜尋
- `slug`：透過 `name` 創建的，拿來建立書本的 `URL` 以及接下來 `Book.getBySlug` 這個函式會用到
- `createdAt`：可以拿來依據書本出版時間做書本呈現的排列
- `price`：書的定價，想收費總要有個定價吧

因此 `models/Book.js` 內的 `BookSchema` 變成：

```JavaScript
const BookSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  price: {
    type: Number,
    required: true,
  },
});
```

---

### 靜態函式

我們先定義四個 `BookClass` 內的靜態函式（`.loadClass()` 會將這些函式加到資料模型內）：

- `Book.list()`：會將 MongoDB 內的 `books` 集合內全部的文件取出。這個函式會回傳一個含有 `books` 屬性的物件，這 `books` 這個物件則是一個 `book` 物件的陣列
- `Book.getBySlug()`：會從 MongoDB 內的 `books` 集合找到符合 `slug` 的 `book` 文件。從 `BookSchema` 可以看到這會是唯一的文件。這個函式回傳就是一個 `book` 物件。我們可以用這個函式來顯示單一本書的內容
- `Book.add()`：會在 MongoDB 新增一個 `books.book` 的文件。我們未來會在一個 `AddBook` 頁面上呼叫這個函式。此函式會回傳所新增的 `book` 物件
- `Book.edit()`：會在 MongoDB 上針對指定的 `book.book` 文件做欄位的更新。我們未來會在 `EditBook` 頁面上呼叫這個函式。此函式會回傳修改後對應的 `book` 物件

因此，我們的 `BookClass` 框架如下：

```JavaScript
// BookClass 定義有哪些操作 Book 的靜態函式
class BookClass {
  static async list({ offset = 0, limit = 10 } = {}) {
    // 程式邏輯
    // 回傳有 books 屬性的物件，而 books 是一個最多有 10 個元素的陣列
  }

  static async getBySlug({ slug }) {
    // 程式邏輯
    // 回傳 book 物件
  }

  static async add({ name, price, githubRepo }) {
    // 程式邏輯
    // 回傳新增的 book 物件
  }

  static async edit({ id, name, price, githubRepo }) {
    // 程式邏輯
    // 回傳修改過後的 book 物件
  }
}
```

我們依序來實作這幾個函式。

---

#### `Book.list()`

```JavaScript
static async list({ offset = 0, limit = 10 } = {}) {
  // 程式邏輯
  const books = await this.find({})
    .sort({ createdAt: -1 })
    .skip(offset)
    .limit(limit);
  // 回傳有 books 屬性的物件，而 books 是一個最多有 10 個元素的陣列
  return { books };
}
```

- `find({})` 會取出所有的資料
- `sort({ createdAt: -1 })` 代表按照書本出版日期排序，`-1` 會從最新的書排到最舊的
- `skip(offset)` 這代表從第 `offset` 本書開始回傳，我們預設 `offset = 0`，因此會從排序後的第一本書開始回傳
  - 雖然目前用不到，但是未來假設書本多的時候，我們可以利用這個值來進行分頁（pagination）處理的工作
- `limit(limit)` 表示最多回傳幾個文件，而預設 `limit = 10`，所以最多回傳 10 本書
  - 限制書本的數量可以減少對 MongoDB 的查詢時間，使用體驗較好
